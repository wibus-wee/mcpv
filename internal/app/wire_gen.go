// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package app

import (
	"context"
	"mcpv/internal/app/bootstrap"
	"mcpv/internal/app/bootstrap/serverinit"
	"mcpv/internal/app/catalog"
	"mcpv/internal/app/controlplane"
	"mcpv/internal/domain"
)

// Injectors from wire.go:

// InitializeApplication wires dependencies for the application.
func InitializeApplication(ctx context.Context, cfg ServeConfig, logging LoggingConfig) (*Application, error) {
	appLogging := NewLogging(logging)
	logger := NewLogger(appLogging)
	registry := NewMetricsRegistry()
	metrics := NewMetrics(registry)
	healthTracker := NewHealthTracker()
	string2 := ConfigPath(cfg)
	dynamicCatalogProvider, err := catalog.NewDynamicCatalogProvider(ctx, string2, logger)
	if err != nil {
		return nil, err
	}
	catalogState, err := catalog.NewCatalogState(ctx, dynamicCatalogProvider)
	if err != nil {
		return nil, err
	}
	launcher := NewCommandLauncher(logger)
	listChangeHub := NewListChangeHub()
	samplingHandler := NewSamplingHandler(ctx, catalogState, logger)
	elicitationHandler := NewElicitationHandler(logger)
	transport := NewMCPTransport(logger, listChangeHub, samplingHandler, elicitationHandler)
	lifecycle := NewLifecycleManager(ctx, launcher, transport, samplingHandler, elicitationHandler, logger)
	pingProbe := NewPingProbe()
	scheduler, err := NewScheduler(lifecycle, catalogState, pingProbe, metrics, healthTracker, logger)
	if err != nil {
		return nil, err
	}
	metadataCache := domain.NewMetadataCache()
	state := newRuntimeState(catalogState, scheduler, metrics, healthTracker, metadataCache, listChangeHub, logger)
	manager := serverinit.NewManager(scheduler, catalogState, logger)
	metadataManager := NewBootstrapManagerProvider(lifecycle, scheduler, catalogState, metadataCache, logger)
	serverStartupOrchestrator := bootstrap.NewServerStartupOrchestrator(manager, metadataManager, logger)
	controlplaneState := provideControlPlaneState(ctx, state, catalogState, scheduler, serverStartupOrchestrator, logger)
	clientRegistry := controlplane.NewClientRegistry(controlplaneState)
	toolDiscoveryService := controlplane.NewToolDiscoveryService(controlplaneState, clientRegistry)
	resourceDiscoveryService := controlplane.NewResourceDiscoveryService(controlplaneState, clientRegistry)
	promptDiscoveryService := controlplane.NewPromptDiscoveryService(controlplaneState, clientRegistry)
	logBroadcaster := NewLogBroadcaster(appLogging)
	service := controlplane.NewObservabilityService(controlplaneState, clientRegistry, logBroadcaster)
	automationService := controlplane.NewAutomationService(controlplaneState, clientRegistry, toolDiscoveryService)
	controlPlane := controlplane.NewControlPlane(controlplaneState, clientRegistry, toolDiscoveryService, resourceDiscoveryService, promptDiscoveryService, service, automationService)
	managerManager, err := NewPluginManager(logger, metrics)
	if err != nil {
		return nil, err
	}
	engine, err := NewPipelineEngine(catalogState, managerManager, metrics, logger)
	if err != nil {
		return nil, err
	}
	executor := NewGovernanceExecutor(engine)
	server := NewRPCServer(controlPlane, executor, catalogState, logger)
	reloadManager := controlplane.NewReloadManager(dynamicCatalogProvider, controlplaneState, clientRegistry, scheduler, serverStartupOrchestrator, managerManager, engine, metrics, healthTracker, metadataCache, listChangeHub, logger)
	applicationOptions := ApplicationOptions{
		Context:           ctx,
		ServeConfig:       cfg,
		Logger:            logger,
		Registry:          registry,
		Metrics:           metrics,
		Health:            healthTracker,
		CatalogState:      catalogState,
		ControlPlaneState: controlplaneState,
		Scheduler:         scheduler,
		Startup:           serverStartupOrchestrator,
		ControlPlane:      controlPlane,
		RPCServer:         server,
		ReloadManager:     reloadManager,
		PluginManager:     managerManager,
	}
	application := NewApplication(applicationOptions)
	return application, nil
}
